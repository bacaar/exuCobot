#!/usr/bin/env python

"""
Author: Aaron Bacher
Date: 20.09.2022

Script for testing creation of polynomial trajectories
-> reads csv with coefficients generated by c++ controller and evaluates them  -> data1
-> reads csv with coefficients generated by offline c++ and evaluates tehm -> data2
-> reads csv with parameters for trajectory generation (used by c++), recreates them with pyhton functions -> data3
-> compares results, should be the same
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import os

from PolynomialTrajectoryAnalysis import evaluatePolynom, calcCoefs

segments = pd.read_csv(os.getcwd() + "/log/trajectoryCreation.csv")
nDrop = 1

def evaluateCoefficients(coefs):
    try:
        coefs["t"] = coefs["s"] + coefs["ns"]*1e-9
    except:
        pass

    # get rid of first nDrop rows
    for i in range(nDrop*3):
        coefs = coefs.drop([i])

    steps = int((coefs.shape[0]) / 3 * 10)

    # provide some space for coordinates (needed for plotting)
    pos1 = np.zeros(shape=(steps, ))
    vel1 = np.zeros(shape=(steps, ))
    acc1 = np.zeros(shape=(steps, ))
    jerk1 = np.zeros(shape=(steps, ))
    
    pos2 = np.zeros(shape=(steps, ))
    vel2 = np.zeros(shape=(steps, ))
    acc2 = np.zeros(shape=(steps, ))
    jerk2 = np.zeros(shape=(steps, ))
    
    pos3 = np.zeros(shape=(steps, ))
    vel3 = np.zeros(shape=(steps, ))
    acc3 = np.zeros(shape=(steps, ))
    jerk3 = np.zeros(shape=(steps, ))
    
    tVec = np.zeros(shape=(steps, ))
    tglobal = coefs["t"][nDrop*3]

    for i0 in range(int(coefs.shape[0]/3)):

        i = i0*3 + nDrop*3

        coefs1 = np.array([coefs["A"][i], coefs["B"][i], coefs["C"][i], coefs["D"][i], coefs["E"][i], coefs["F"][i]])
        coefs2 = np.array([coefs["A"][i+1], coefs["B"][i+1], coefs["C"][i+1], coefs["D"][i+1], coefs["E"][i+1], coefs["F"][i+1]])
        coefs3 = np.array([coefs["A"][i+2], coefs["B"][i+2], coefs["C"][i+2], coefs["D"][i+2], coefs["E"][i+2], coefs["F"][i+2]])

        t = 0
        j = i0*10
        dt = 0.01

        while(t < dt):
        
            pos1[j], vel1[j], acc1[j], jerk1[j] = evaluatePolynom(coef=coefs1, t=t)
            pos2[j], vel2[j], acc2[j], jerk2[j] = evaluatePolynom(coef=coefs2, t=t)
            pos3[j], vel3[j], acc3[j], jerk3[j] = evaluatePolynom(coef=coefs3, t=t)

            tVec[j] = tglobal

            tglobal += 0.001
            t += 0.001
            j += 1

    data = np.array([[pos1, vel1, acc1, jerk1],
                     [pos2, vel2, acc2, jerk2],
                     [pos3, vel3, acc3, jerk3]]).T

    return tVec, data


def offlineCalculation(polyOrder):
        
    global segments

    # get rid of first nDrop rows
    for i in range(nDrop):
        segments = segments.drop([i])

    steps = (segments.shape[0]-1) * 10

    # provide some space for coordinates (needed for plotting)
    pos1 = np.zeros(shape=(steps, ))
    vel1 = np.zeros(shape=(steps, ))
    acc1 = np.zeros(shape=(steps, ))
    jerk1 = np.zeros(shape=(steps, ))
    
    pos2 = np.zeros(shape=(steps, ))
    vel2 = np.zeros(shape=(steps, ))
    acc2 = np.zeros(shape=(steps, ))
    jerk2 = np.zeros(shape=(steps, ))
    
    pos3 = np.zeros(shape=(steps, ))
    vel3 = np.zeros(shape=(steps, ))
    acc3 = np.zeros(shape=(steps, ))
    jerk3 = np.zeros(shape=(steps, ))
    
    tVec = np.zeros(shape=(steps, ))

    # poynomial coefficients
    coefs1 = np.zeros(shape=(polyOrder + 1, ))
    coefs2 = np.zeros(shape=(polyOrder + 1, ))
    coefs3 = np.zeros(shape=(polyOrder + 1, ))

    #print(segments)
    tglobal = segments["t"][nDrop]

    for i0 in range(segments.shape[0]):

        i = i0 + nDrop

        vec = np.empty(shape=(3,2))
        vec[0,0] = segments["cpy"][i]
        vec[1,0] = segments["cvy"][i]
        vec[2,0] = segments["cay"][i]
        vec[0,1] = segments["npy"][i]
        vec[1,1] = segments["nvy"][i]
        vec[2,1] = segments["nay"][i]

        coefs1 = calcCoefs(segments["cpx"][i], segments["cvx"][i], segments["cax"][i], segments["npx"][i], segments["nvx"][i], segments["nax"][i], segments["dt"][i], polyOrder)
        coefs2 = calcCoefs(segments["cpy"][i], segments["cvy"][i], segments["cay"][i], segments["npy"][i], segments["nvy"][i], segments["nay"][i], segments["dt"][i], polyOrder)
        coefs3 = calcCoefs(segments["cpz"][i], segments["cvz"][i], segments["caz"][i], segments["npz"][i], segments["nvz"][i], segments["naz"][i], segments["dt"][i], polyOrder)

        t = 0
        j = (i0-1)*10

        while(t < segments["dt"][i]):
        
            pos1[j], vel1[j], acc1[j], jerk1[j] = evaluatePolynom(coef=coefs1, t=t)
            pos2[j], vel2[j], acc2[j], jerk2[j] = evaluatePolynom(coef=coefs2, t=t)
            pos3[j], vel3[j], acc3[j], jerk3[j] = evaluatePolynom(coef=coefs3, t=t)

            #tVec[j] = segments["t"][i] + t
            tVec[j] = tglobal

            tglobal += 0.001
            t += 0.001
            j += 1

    data = np.array([[pos1, vel1, acc1, jerk1],
                     [pos2, vel2, acc2, jerk2],
                     [pos3, vel3, acc3, jerk3]]).T

    return tVec, data


def main():
    polyOrder = 5

    coefs = pd.read_csv(os.getcwd() + "/log/coefficients.log")
    coefsCpp = pd.read_csv(os.getcwd() + "/log/coefficientsCpp.csv")

    t1, data1 = evaluateCoefficients(coefs)
    t2, data2 = evaluateCoefficients(coefsCpp)
    t3, data3 = offlineCalculation(polyOrder)

    fig, axs = plt.subplots(4, 3, sharex=True)#, sharey="row")
    labels = ["s in m", "v in m/s", "a in m/s2", "j in m/s3"]
    
    axs[0][0].set_ylabel(labels[0])
    axs[0][0].grid()
    axs[1][0].set_ylabel(labels[1])
    axs[1][0].grid()
    axs[2][0].set_ylabel(labels[2])
    axs[2][0].grid()
    axs[3][0].set_ylabel(labels[3])
    axs[3][0].grid()
    axs[3][0].set_xlabel("t in s")
    axs[0][0].set_title("x-axis")

    axs[0][1].grid()
    axs[1][1].grid()
    axs[2][1].grid()
    axs[3][1].grid()
    axs[3][1].set_xlabel("t in s")
    axs[0][1].set_title("y-axis")

    axs[0][2].grid()
    axs[1][2].grid()
    axs[2][2].grid()
    axs[3][2].grid()
    axs[3][2].set_xlabel("t in s")
    axs[0][2].set_title("z-axis")

    for i in range(4):
        for j in range(3):
            axs[i][j].plot(t1, data1[:,i,j])
            axs[i][j].plot(t2, data2[:,i,j])
            axs[i][j].plot(t3, data3[:,i,j], "--")

    # plot start and end position of segments
    axs[0][0].plot(np.array(segments["t"]), np.array(segments["cpx"]), "x")
    axs[0][1].plot(np.array(segments["t"]), np.array(segments["cpy"]), "x")
    axs[0][2].plot(np.array(segments["t"]), np.array(segments["cpz"]), "x")
    axs[0][0].plot(np.array(segments["t"]+segments["dt"]), np.array(segments["npx"]), "x")
    axs[0][1].plot(np.array(segments["t"]+segments["dt"]), np.array(segments["npy"]), "x")
    axs[0][2].plot(np.array(segments["t"]+segments["dt"]), np.array(segments["npz"]), "x")
        
    fig.legend(["trajectory c++ controller", "trajectory c++ offline", "trajectory pyhton"])
    fig.set_tight_layout(True)
    plt.show()


if __name__ == "__main__":
    main()